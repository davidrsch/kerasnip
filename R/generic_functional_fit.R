#' Generic Keras Functional API Model Fitting Implementation
#'
#' @description
#' This function is the internal engine for fitting models generated by
#' `create_keras_functional_spec()`. It is not intended to be called directly
#' by the user.
#'
#' @details
#' This function performs the following key steps:
#' \enumerate{
#'   \item \strong{Argument & Data Preparation:} It resolves arguments passed
#'     from `parsnip` (handling `rlang_zap` objects for unspecified arguments)
#'     and prepares the `x` and `y` data for Keras. It automatically determines
#'     the `input_shape` from `x` and, for classification, the `num_classes`
#'     from `y`.
#'   \item \strong{Dynamic Model Construction:} It builds the Keras model graph
#'     by processing the `layer_blocks` list.
#'     \itemize{
#'       \item \strong{Connectivity:} The graph is connected by matching the
#'         argument names of each block function to the names of previously
#'         defined blocks. For example, a block `function(input_a, ...)` will
#'         receive the output tensor from the block named `input_a`.
#'       \item \strong{Repetition:} It checks for `num_{block_name}` arguments
#'         to repeat a block multiple times, creating a chain of identical
#'         layers. A block can only be repeated if it has exactly one input
#'         tensor from another block.
#'     }
#'   \item \strong{Model Compilation:} It compiles the final Keras model. The
#'     compilation arguments (optimizer, loss, metrics) can be customized by
#'     passing arguments prefixed with `compile_` (e.g., `compile_loss = "mae"`).
#'   \item \strong{Model Fitting:} It calls `keras3::fit()` to train the model
#'     on the prepared data.
#' }
#'
#' @param x A data frame or matrix of predictors.
#' @param y A vector of outcomes.
#' @param layer_blocks A named list of layer block functions. This is passed
#'   internally from the `parsnip` model specification.
#' @param ... Additional arguments passed down from the model specification.
#'   These can include:
#'   \itemize{
#'     \item \strong{Layer Parameters:} Arguments for the layer blocks, prefixed
#'       with the block name (e.g., `dense_units = 64`).
#'     \item \strong{Architecture Parameters:} Arguments to control the number
#'       of times a block is repeated, in the format `num_{block_name}` (e.g.,
#'       `num_dense = 2`).
#'     \item \strong{Compile Parameters:} Arguments to customize model
#'       compilation, prefixed with `compile_` (e.g., `compile_loss = "mae"`,
#'       `compile_optimizer = "sgd"`).
#'     \item \strong{Fit Parameters:} Arguments to customize model fitting,
#'       prefixed with `fit_` (e.g., `fit_callbacks = list(...)`,
#'       `fit_class_weight = list(...)`).
#'   }
#'
#' @return A list containing the fitted model and other metadata. This list is
#'   stored in the `fit` slot of the `parsnip` model fit object. The list
#'   contains the following elements:
#'   \itemize{
#'     \item `fit`: The raw, fitted Keras model object.
#'     \item `history`: The Keras training history object.
#'     \item `lvl`: A character vector of the outcome factor levels (for
#'       classification) or `NULL` (for regression).
#'   }
#' @keywords internal
#' @export
generic_functional_fit <- function(
  formula,
  data,
  layer_blocks,
  ...
) {
  # Separate predictors and outcomes from the processed data frame provided by parsnip
  y_names <- all.vars(formula[[2]])
  x_names <- all.vars(formula[[3]])

  # Handle the `.` case for predictors
  if ("." %in% x_names) {
    x <- data[, !(names(data) %in% y_names), drop = FALSE]
  } else {
    x <- data[, x_names, drop = FALSE]
  }
  y <- data[, y_names, drop = FALSE]
  # --- 1. Build and Compile Model ---
  model <- build_and_compile_functional_model(x, y, layer_blocks, ...)

  # --- 2. Model Fitting ---
  all_args <- list(...)
  verbose <- all_args$verbose %||% 0
  x_processed <- process_x(x)
  x_proc <- x_processed$x_proc
  y_processed <- process_y(y)
  y_mat <- y_processed$y_proc

  fit_args <- collect_fit_args(
    x_proc,
    y_mat,
    verbose,
    all_args
  )

  # Fit the model using the constructed arguments
  history <- rlang::exec(keras3::fit, model, !!!fit_args)

  # --- 3. Return value ---
  list(
    fit = model, # The raw Keras model object
    history = history, # The training history
    lvl = y_processed$class_levels # Factor levels for classification, NULL for regression
  )
}
