#' Post-process Keras Numeric Predictions
#'
#' Formats raw numeric predictions from a Keras model into a tibble with a
#' standardized `.pred` column.
#'
#' @param results A matrix of numeric predictions from `predict()`.
#' @param object The `parsnip` model fit object.
#' @return A tibble with a `.pred` column.
#' @noRd
keras_postprocess_numeric <- function(results, object) {
  tibble::tibble(.pred = as.vector(results))
}

#' Post-process Keras Probability Predictions
#'
#' Formats raw probability predictions from a Keras model into a tibble
#' with class-specific column names.
#'
#' @param results A matrix of probability predictions from `predict()`.
#' @param object The `parsnip` model fit object.
#' @return A tibble with named columns for each class probability.
#' @noRd
keras_postprocess_probs <- function(results, object) {
  # The levels are now nested inside the fit object
  colnames(results) <- object$fit$lvl
  tibble::as_tibble(results)
}

#' Post-process Keras Class Predictions
#'
#' Converts raw probability predictions from a Keras model into factor-based
#' class predictions.
#'
#' @param results A matrix of probability predictions from `predict()`.
#' @param object The `parsnip` model fit object.
#' @return A tibble with a `.pred_class` column containing factor predictions.
#' @noRd
keras_postprocess_classes <- function(results, object) {
  # The levels are now nested inside the fit object
  lvls <- object$fit$lvl
  if (ncol(results) == 1) {
    # Binary classification
    pred_class <- ifelse(results[, 1] > 0.5, lvls[2], lvls[1])
    pred_class <- factor(pred_class, levels = lvls)
  } else {
    # Multiclass classification
    pred_class_int <- apply(results, 1, which.max)
    pred_class <- lvls[pred_class_int]
    pred_class <- factor(pred_class, levels = lvls)
  }
  tibble::tibble(.pred_class = pred_class)
}

#' Discover and Collect Model Specification Arguments
#'
#' Introspects the provided layer block functions to generate a list of
#' arguments for the new model specification. This includes arguments for
#' block repetition (`num_*`), block-specific hyperparameters (`block_*`),
#' and global training parameters.
#'
#' @param layer_blocks A named list of functions defining Keras layer blocks.
#' @param global_args A character vector of global arguments to add to the
#'   specification (e.g., "epochs").
#' @return A list containing two elements:
#'   - `all_args`: A named list of arguments for the new function signature,
#'     initialized with `rlang::zap()`.
#'   - `parsnip_names`: A character vector of all argument names for `parsnip`.
#' @noRd
collect_spec_args <- function(
  layer_blocks,
  global_args = c(
    "epochs",
    "batch_size",
    "learn_rate",
    "validation_split",
    "verbose",
    "compile_loss",
    "compile_optimizer",
    "compile_metrics"
  )
) {
  if (any(c("compile", "optimizer") %in% names(layer_blocks))) {
    stop(
      "`compile` and `optimizer` are protected names and cannot be used as layer block names.",
      call. = FALSE
    )
  }

  all_args <- list()
  parsnip_names <- character()

  # block repetition counts (e.g., num_dense)
  for (block in names(layer_blocks)) {
    num_name <- paste0("num_", block)
    all_args[[num_name]] <- rlang::zap()
    parsnip_names <- c(parsnip_names, num_name)
  }

  # These args are passed by the fit engine, not set by the user in the spec
  engine_args <- c("input_shape", "num_classes")
  # block-specific parameters (skip first 'model' formal)
  for (block in names(layer_blocks)) {
    fmls_to_process <- rlang::fn_fmls(layer_blocks[[block]])[-1]
    # Filter out arguments that are provided by the fitting engine
    for (arg in names(fmls_to_process[
      !names(fmls_to_process) %in% engine_args
    ])) {
      full <- paste0(block, "_", arg)
      all_args[[full]] <- rlang::zap()
      parsnip_names <- c(parsnip_names, full)
    }
  }

  # global training parameters
  for (g in global_args) {
    all_args[[g]] <- rlang::zap()
    parsnip_names <- c(parsnip_names, g)
  }

  list(all_args = all_args, parsnip_names = parsnip_names)
}

#' Generate Roxygen Documentation for a Dynamic Spec Function
#'
#' Constructs a detailed Roxygen comment block as a string, which can be
#' attached to the dynamically created model specification function.
#'
#' @param model_name The name of the model.
#' @param layer_blocks The list of layer block functions.
#' @param all_args A named list of all arguments for the function signature.
#' @return A single string containing the full Roxygen documentation.
#' @noRd
generate_roxygen_docs <- function(model_name, layer_blocks, all_args) {
  # Title and Description
  title <- paste(
    gsub("_", " ", tools::toTitleCase(model_name)),
    "Model Specification"
  )
  desc <- paste0(
    "Defines a `parsnip` model specification for a Keras model built with ",
    "custom layer blocks. This function was generated by `kerasnip::create_keras_spec()`."
  )

  # Parameters
  param_docs <- c()
  arg_names <- names(all_args)

  # Group args for structured documentation
  num_params <- arg_names[startsWith(arg_names, "num_")]
  compile_params <- arg_names[startsWith(arg_names, "compile_")]
  global_params <- c(
    "epochs",
    "batch_size",
    "learn_rate",
    "validation_split",
    "verbose"
  )
  block_params <- setdiff(
    arg_names,
    c(num_params, compile_params, global_params)
  )

  # Document block-specific params
  if (length(block_params) > 0) {
    param_docs <- c(
      param_docs,
      purrr::map_chr(block_params, function(p) {
        parts <- strsplit(p, "_", fixed = TRUE)[[1]]
        block_name <- parts[1]
        param_name <- paste(parts[-1], collapse = "_")
        block_fn <- layer_blocks[[block_name]]
        default_val <- rlang::fn_fmls(block_fn)[[param_name]]
        default_str <- if (
          !is.null(default_val) && !rlang::is_missing(default_val)
        ) {
          paste0(
            " Defaults to `",
            deparse(default_val, width.cutoff = 500L),
            "`."
          )
        } else {
          ""
        }
        paste0(
          "@param ",
          p,
          " The `",
          param_name,
          "` for the '",
          block_name,
          "' block.",
          default_str
        )
      })
    )
  }

  # Document architecture params
  if (length(num_params) > 0) {
    param_docs <- c(
      param_docs,
      purrr::map_chr(num_params, function(p) {
        block_name <- sub("num_", "", p)
        paste0(
          "@param ",
          p,
          " The number of times to repeat the '",
          block_name,
          "' block. Defaults to 1."
        )
      })
    )
  }

  # Document global params
  global_param_desc <- list(
    epochs = "The total number of iterations to train the model.",
    batch_size = "The number of samples per gradient update.",
    learn_rate = "The learning rate for the default Adam optimizer. This is ignored if `compile_optimizer` is provided as a pre-built object.",
    validation_split = "The proportion of the training data to be used as a validation set.",
    verbose = "The level of verbosity for model fitting (0, 1, or 2)."
  )
  param_docs <- c(
    param_docs,
    purrr::map_chr(global_params, function(p) {
      paste0("@param ", p, " ", global_param_desc[[p]])
    })
  )

  # Document compile params
  compile_param_desc <- list(
    compile_loss = "The loss function for compiling the model. Can be a string (e.g., 'mse') or a Keras loss object. Overrides the default.",
    compile_optimizer = "The optimizer for compiling the model. Can be a string (e.g., 'sgd') or a Keras optimizer object. Overrides the default.",
    compile_metrics = "A character vector of metrics to monitor during training (e.g., `c('mae', 'mse')`). Overrides the default."
  )
  param_docs <- c(
    param_docs,
    purrr::map_chr(compile_params, function(p) {
      paste0("@param ", p, " ", compile_param_desc[[p]])
    })
  )

  # Add ... param
  param_docs <- c(
    param_docs,
    "@param ... Additional arguments passed to `parsnip::new_model_spec()`."
  )

  # Sections
  architecture_section <- c(
    "#' @section Model Architecture:",
    "#' The Keras model is constructed by sequentially applying the layer blocks in the order they were provided to `create_keras_spec()`.",
    "#' You can control the number of times each block is repeated by setting the `num_{block_name}` argument (e.g., `num_dense = 2`).",
    "#' This allows for dynamically creating deeper or more complex architectures during tuning."
  )

  compilation_section <- c(
    "#' @section Model Compilation:",
    "#' The model is compiled with a default optimizer, loss function, and metric based on the model's mode. You can override these defaults by providing arguments prefixed with `compile_`.",
    "#' \\itemize{",
    "#'   \\item \\strong{Optimizer}: Defaults to `keras3::optimizer_adam()` using the `learn_rate` argument. Override with `compile_optimizer` (e.g., `\"sgd\"` or `keras3::optimizer_sgd(...)`).",
    "#'   \\item \\strong{Loss}: Defaults to `\"mean_squared_error\"` for regression and `\"categorical_crossentropy\"` or `\"binary_crossentropy\"` for classification. Override with `compile_loss`.",
    "#'   \\item \\strong{Metrics}: Defaults to `\"mean_absolute_error\"` for regression and `\"accuracy\"` for classification. Override with `compile_metrics` (e.g., `c(\"mae\", \"mape\")`).",
    "#' }",
    "#' For more details, see the documentation for `kerasnip::generic_keras_fit_impl`."
  )

  fitting_section <- c(
    "#' @section Model Fitting:",
    "#' The model is fit using `keras3::fit()`. You can pass any argument to this function by prefixing it with `fit_`.",
    "#' For example, to add Keras callbacks, you can pass `fit_callbacks = list(callback_early_stopping())`.",
    "#' The `epochs` and `batch_size` arguments are also passed to `fit()`."
  )

  # Other tags
  other_tags <- c(
    "#' @seealso [create_keras_spec()], [generic_keras_fit_impl()]",
    "#' @export"
  )

  # Combine all parts
  paste(
    c(
      paste0("#' ", title),
      "#'",
      paste0("#' ", desc),
      "#'",
      paste0("@", param_docs),
      architecture_section,
      fitting_section,
      compilation_section,
      other_tags
    ),
    collapse = "\n"
  )
}

#' Build the Model Specification Function
#'
#' Uses metaprogramming to construct the new model specification function
#' (e.g., `dynamic_mlp()`). This function will capture user-provided arguments
#' and package them into a `parsnip::new_model_spec()` call.
#'
#' @param model_name The name of the model specification function to create.
#' @param mode The model mode ("regression" or "classification").
#' @param all_args A named list of arguments for the function signature, as
#'   generated by `collect_spec_args()`.
#' @param parsnip_names A character vector of all argument names.
#' @return A new function that serves as the `parsnip` model specification.
#' @noRd
build_spec_function <- function(
  model_name,
  mode,
  all_args,
  parsnip_names,
  layer_blocks
) {
  quos_exprs <- purrr::map(
    parsnip_names,
    ~ rlang::expr(rlang::enquo(!!rlang::sym(.x)))
  )
  names(quos_exprs) <- parsnip_names

  body <- rlang::expr({
    # Capture both explicit args and ... to pass to the fit impl
    # Named arguments are captured into a list of quosures.
    main_args <- rlang::list2(!!!quos_exprs)
    # ... arguments are captured into a separate list of quosures.
    dot_args <- rlang::enquos(...)
    args <- c(main_args, dot_args)
    parsnip::new_model_spec(
      !!model_name,
      args = args,
      eng_args = NULL,
      mode = !!mode,
      method = NULL,
      engine = NULL
    )
  })

  # Add ... to the function signature to capture any other compile arguments
  fn_args <- c(all_args, list(... = rlang::missing_arg()))

  fn <- rlang::new_function(args = fn_args, body = body)

  docs <- generate_roxygen_docs(model_name, layer_blocks, all_args)
  comment(fn) <- docs
  fn
}

#' Register Core Model Information with Parsnip
#'
#' Sets up the basic model definition with `parsnip`, including its mode,
#' engine, dependencies, and data encoding requirements.
#'
#' @param model_name The name of the new model.
#' @param mode The model mode ("regression" or "classification").
#' @return Invisibly returns `NULL`. Called for its side effects.
#' @noRd
register_core_model <- function(model_name, mode) {
  parsnip::set_new_model(model_name)
  parsnip::set_model_mode(model_name, mode)
  parsnip::set_model_engine(model_name, mode, "keras")
  parsnip::set_dependency(model_name, "keras", "keras3")

  parsnip::set_encoding(
    model = model_name,
    eng = "keras",
    mode = mode,
    options = list(
      predictor_indicators = "traditional",
      compute_intercept = TRUE,
      remove_intercept = TRUE,
      allow_sparse_x = FALSE
    )
  )
}

#' Register Model Arguments with Parsnip
#'
#' Registers each model argument with `parsnip` and maps it to a corresponding
#' `dials` parameter function for tuning. This allows `tidymodels` to know
#' about the tunable parameters of the custom model.
#'
#' @param model_name The name of the new model.
#' @param parsnip_names A character vector of all argument names.
#' @return Invisibly returns `NULL`. Called for its side effects.
#' @noRd
register_model_args <- function(model_name, parsnip_names) {
  keras_dials_map <- tibble::tribble(
    ~keras_arg,
    ~dials_fun,
    "units",
    "hidden_units",
    "filters",
    "hidden_units",
    "kernel_size",
    "kernel_size",
    "pool_size",
    "pool_size",
    "dropout",
    "dropout",
    "rate",
    "dropout",
    "learn_rate",
    "learn_rate",
    "epochs",
    "epochs",
    "batch_size",
    "batch_size",
    "compile_loss", # parsnip arg
    "loss_function_keras", # dials function from kerasnip
    "compile_optimizer", # parsnip arg
    "optimizer_function" # dials function from kerasnip
  )

  # We now allow optimizer to be tuned. Metrics are for tracking, not training.
  non_tunable <- c("verbose")

  for (arg in parsnip_names) {
    if (arg %in% non_tunable) {
      next
    }

    if (startsWith(arg, "num_")) {
      dials_fun <- "num_terms"
    } else {
      base_arg <- sub(".*_", "", arg)
      idx <- match(base_arg, keras_dials_map$keras_arg)
      dials_fun <- if (!is.na(idx)) keras_dials_map$dials_fun[idx] else arg
    }

    parsnip::set_model_arg(
      model = model_name,
      eng = "keras",
      parsnip = arg,
      original = arg,
      func = list(pkg = "dials", fun = dials_fun),
      has_submodel = FALSE
    )
  }
}

#' Register Fit and Prediction Methods with Parsnip
#'
#' Defines how to fit the custom Keras model and how to generate predictions
#' for both regression and classification modes. It links the model to the
#' generic fitting implementation (`generic_keras_fit_impl`) and sets up
#' the appropriate prediction post-processing.
#'
#' @param model_name The name of the new model.
#' @param mode The model mode ("regression" or "classification").
#' @param layer_blocks The named list of layer block functions, which is passed
#'   as a default argument to the fit function.
#' @return Invisibly returns `NULL`. Called for its side effects.
#' @noRd
register_fit_predict <- function(model_name, mode, layer_blocks) {
  # Fit method
  parsnip::set_fit(
    model = model_name,
    eng = "keras",
    mode = mode,
    value = list(
      interface = "data.frame",
      protect = c("x", "y"),
      func = c(pkg = "kerasnip", fun = "generic_keras_fit_impl"),
      defaults = list(layer_blocks = layer_blocks)
    )
  )

  # Regression prediction
  if (mode == "regression") {
    parsnip::set_pred(
      model = model_name,
      eng = "keras",
      mode = "regression",
      type = "numeric",
      value = list(
        pre = NULL,
        post = keras_postprocess_numeric,
        func = c(fun = "predict"),
        args = list(
          object = rlang::expr(object$fit$fit),
          x = rlang::expr(as.matrix(new_data))
        )
      )
    )
  } else {
    # Classification predictions
    parsnip::set_pred(
      model = model_name,
      eng = "keras",
      mode = "classification",
      type = "class",
      value = list(
        pre = NULL,
        post = keras_postprocess_classes,
        func = c(fun = "predict"),
        args = list(
          object = rlang::expr(object$fit$fit),
          x = rlang::expr(as.matrix(new_data))
        )
      )
    )
    parsnip::set_pred(
      model = model_name,
      eng = "keras",
      mode = "classification",
      type = "prob",
      value = list(
        pre = NULL,
        post = keras_postprocess_probs,
        func = c(fun = "predict"),
        args = list(
          object = rlang::expr(object$fit$fit),
          x = rlang::expr(as.matrix(new_data))
        )
      )
    )
  }
}

#' Register the `update()` S3 Method
#'
#' Creates and registers an `update()` S3 method for the new model specification.
#' This method allows users to modify the model's parameters after it has been
#' created, which is essential for tuning with `dials` and `tune`.
#'
#' @param model_name The name of the new model.
#' @param parsnip_names A character vector of all argument names.
#' @return Invisibly returns `NULL`. Called for its side effects.
#' @noRd
register_update_method <- function(model_name, parsnip_names) {
  # Build function signature
  update_args_list <- c(
    list(object = rlang::missing_arg(), parameters = rlang::expr(NULL)),
    purrr::map(parsnip_names, ~ rlang::expr(NULL)),
    list(... = rlang::missing_arg(), fresh = rlang::expr(FALSE))
  )
  names(update_args_list)[3:(2 + length(parsnip_names))] <- parsnip_names

  # Create a list of expressions like `arg_name = rlang::enquo(arg_name)`
  args_enquo_exprs <- purrr::map(
    parsnip_names,
    ~ rlang::expr(rlang::enquo(!!rlang::sym(.x)))
  )
  names(args_enquo_exprs) <- parsnip_names

  # Create the expression that builds this list inside the function body
  args_enquo_list_expr <- rlang::expr(
    args <- rlang::list2(!!!args_enquo_exprs)
  )

  # Create the call to `parsnip::update_spec`
  update_spec_call <- rlang::expr(
    parsnip::update_spec(
      object = object,
      parameters = parameters,
      args_enquo_list = args,
      fresh = fresh,
      cls = !!model_name,
      ...
    )
  )

  # Combine them into the final body
  update_body <- rlang::call2("{", args_enquo_list_expr, update_spec_call)

  # Create and register the S3 method
  update_func <- rlang::new_function(
    args = update_args_list,
    body = update_body
  )
  method_name <- paste0("update.", model_name)
  rlang::env_poke(environment(), method_name, update_func)
  registerS3method("update", model_name, update_func, envir = environment())
}
